'''
SuperLinker by ddthj/Squidfairy
V1.1

Superlinker is a chatbot designed to generate random sentences based on a "brain"
generated by feeding it literature or random text.

'''
import discord
import random
import asyncio
import logging
import cryptoSafe as c
import re
import pickle
import random
import time


sd = 5 # not sure if this is needed here but better make sure xD


def readFile(file):
    data = pickle.load(open(file,'rb'))
    return data

def writeFile(data, file):
    pickle.dump(data,open(file,'wb'))

class word():
    def __init__(self,name,treeDepth,followers,start):
        self.name = name #name of the word
        self.branches = [] #what words follow this word
        self.treeDepth = treeDepth
        self.counts = 1
        self.sd = 5 #standard tree depth
        if len(followers) > 0:
            self.end = False
        else:
            self.end = True
        self.plusFollower(followers)
        self.start = start
        
    def plusFollower(self,followers):
        flog = True
        if len(followers)>0:
            try:
                for item in self.branches:
                    if item.name == str(followers[0]):
                        item.counts +=1
                        followers.pop(0)
                        item.plusFollower(followers)
                        flog = False
                        break
                if flog and self.treeDepth < sd:
                    newFollow = followers[1:]
                    self.branches.append(word(str(followers[0]),self.treeDepth+1,newFollow,False))
            except Exception as e:
                print (str(e))
                print(str(followers))

    def toString(self):
        print(str(self.name)+str(self.counts)+"<",end="")
        for item in self.branches:
            item.toString()
        print(">",end="")

    def twoString(self):
        mess = ""
        mess += str(self.name)+str(self.counts)+"<"
        for item in self.branches:
            mess += str(item.twoString())
        mess += ">"
        return mess

class SuperLinker(discord.Client):
    def __init__(self):
        super().__init__()
        logging.basicConfig()
        self.mode = 1 #-1==testing, 0==training, 1=live,2=live,training
        self.delvl = 0 #how much you want console spammed from -1 -> 4
        self.brainFile = "discord.dat"
        self.trainFile = "training.txt"
        self.client = discord.Client()
        self.access = str(c.de("12EGBqDppFtv"))
        self.sd = 5 #standard tree depth
        self.passEnds = ["kittens","puppies","ducklings","koalas","chicks","penguins","kiwi"]
        self.passTotal = "Save"+str(random.randint(5,99))+str(self.passEnds[random.randint(0,len(self.passEnds)-1)])
        self.passID = 1
        print("PASSWORD = " + str(self.passTotal) + " ID = %s" % (str(self.passID)))
        try:
            print("Loading brain")
            self.brain = readFile(self.brainFile)
            print("Brain loaded")
        except:
            self.brain = []
            print("No brain was loaded")
            
        if self.mode == 0:
            self.trainLinker()
        if self.mode > 0:
            print("logging in")
            self.logn()
    def newPass(self):
        self.passTotal = "Save"+str(random.randint(5,99))+str(self.passEnds[random.randint(0,len(self.passEnds)-1)])
        self.passID += 1
        print("PASSWORD = " + str(self.passTotal) + " ID = " + str(self.passID))
            
    def logn(self):
        try:
            #client.run("theddthj@gmail.com", str(self.access))
            try:
                self.loop.run_until_complete(self.start("theddthj@gmail.com", str(self.access)))
            except discord.errors.LoginFailure:
                print("error logging in")
            print("ran client")
        except Exception as e:
            print("Error loading brain/Connecting to discord:\n")
            print(str(e))
            
    #@client.async_event
    async def on_ready(self):
        print('Logged in as')
        print(self.user.name)
        print(self.user.id)
        print('------')
        
    #@client.async_event
    async def on_message(self,message):
        if message.author != message.server.me:
            print(str(message.content))
            time.sleep(0.2)
            if self.mode == 2:
                if self.delvl > 2:
                    print("going to LiveTrain")
                if message.content.find("``") == -1:
                    self.livetrain(message.content)
                
            if message.content.startswith("``oi"):
                await self.send_message(message.channel,"oi! I'm a bot :P")
            elif message.content.startswith("``fix"):
                await self.send_message(message.channel,"I need to go make changes to my discord bot...")
                exit()  
            elif message.content.startswith("``u"):
                mess = "http"
                while mess.find("http") != -1:
                    mess = str(self.makeMessage())
                await self.send_message(message.channel,mess)
                
            elif message.content.startswith("``start with "):
                parems = message.content.split(" ")
                topic = parems[2].lower()
                if len(parems) >= 4:
                    subTopic = parems[3].lower()
                    flag = True
                    for item in self.brain:
                        if item.name == topic:
                            for subitem in item.branches:
                                if subitem.name == subTopic:
                                    mess = "http"
                                    while mess.find("http") != -1:
                                        mess = str(item.name) + " "+self.custom(subitem)  
                                    await self.send_message(message.channel,mess)
                                    flag = False
                                    break
                    if flag:
                        await self.send_message(message.channel,"I can't make a sentence with those words!")
                else:
                    flag = True
                    for item in self.brain:
                        if item.name == topic:
                            mess = "http"
                            while mess.find("http") != -1:
                                mess = self.custom(item)
                                
                            await self.send_message(message.channel,mess)
                            flag = False
                            break
                    if flag:
                        await self.send_message(message.channel,"I don't know that word!")

            elif message.content.startswith("``help"):
                mess = "Commands:\noi - says hi\nu - utter a sentence\nstart with <word1> <optional word2> - makes a sentence with that word\ninfo on word <word> - find knowledge on that word\ninfo on brain - learn about the brain\nstatus - get general stats about the bot\nchangeBrain/changeMode - change how the bot thinks/operates, requires password to use\nnewPassword - creates a new password"
                await self.send_message(message.channel,mess)
                    
            elif message.content.startswith("``info on brain"):
                lowest = []
                length = len(self.brain)
                totalBranches = 0
                for item in self.brain:
                    if len(item.branches) <=1:
                        lowest.append(str(item.name))
                    totalBranches += len(item.branches)
                if length != 0:
                    density = totalBranches / length
                else:
                    density = 0
                picks = ""
                
                for a in range(0,3):
                    a = "http"
                    while a.find("http") != -1:
                        a = str(lowest[random.randint(0,len(lowest)-1)]) + ", "
                    picks += a
                    
                mess = "!! Brain Info !!\nName: %s,\nSize: %s main words,\nDensity: %s,\nLonely words include: %s" % (str(self.brainFile), str(length),str(density), picks)
                await self.send_message(message.channel,mess)
                   
            elif message.content.startswith("``info on word "):
                flag = False
                for item in self.brain:
                    if item.name == str(message.content.split(" ")[3].lower()):
                        flag = True
                        mess = str(item.twoString())
                        if len(mess) > 300:
                            await self.send_message(message.channel,"I'm afraid I know too much about that word to share this knowledge with you.")
                        else:
                            await self.send_message(message.channel,mess)
                if flag == False:
                    await self.send_message(message.channel,"I don't know that word!")

            elif message.content.startswith("``force info on "):
                flag = False
                for item in self.brain:
                    if item.name == str(message.content.split(" ")[3].lower()):
                        flag = True
                        mess = str(item.twoString())
                        if len(mess) > 2000:
                            await self.send_message(message.channel,"Info above max character limit, ;-;")
                        else:
                            await self.send_message(message.channel,mess)
                if flag == False:
                    await self.send_message(message.channel,"I don't know that word!")
                    
            elif message.content.startswith("``changeMode "):
                acpas = message.content.split(" ")[1]
                mode = message.content.split(" ")[2]
                if acpas == self.passTotal:
                    self.mode = int(mode)
                    self.newPass()
                    modeDesc = ["Training mode (not live)","Live mode","Training live mode"]
                    mess = "Mode changed to " + str(self.mode) +", "+ str(modeDesc[int(self.mode)])
                    await self.send_message(message.channel,mess)

            elif message.content.startswith("``changeBrain "):
                acpas = message.content.split(" ")[1]
                fileName = message.content.split(" ")[2]
                if acpas == self.passTotal:
                    self.newPass()
                    writeFile(self.brain,self.brainFile)
                    try:
                        self.brain = readFile(fileName)
                        self.brainFile = str(fileName)
                        await self.send_message(message.channel,"Brain changed sucessfully!")
                    except:
                        if message.content.find("force") != -1:
                            self.brain = []
                            self.brainFile = str(fileName)
                            await self.send_message(message.channel,"Forced a new brain into existance")
                        else:
                            await self.send_message(message.channel,"No brain loaded, check spelling?")
                            
            elif message.content.startswith("``status"):
                currentBrain = self.brainFile
                currentMode = self.mode
                currentID = self.passID

                await self.send_message(message.channel,"Current brain: %s\nCurrent mode: %s\nCurrent password ID: %s" % (str(currentBrain),str(currentMode),str(currentID)))
                
            elif message.content.startswith("``newPassword"):
                self.newPass()
                await self.send_message(message.channel,"New password generated, ID# %s" % (str(self.passID)))

            elif message.content.startswith("``saveBrain "):
                if message.content.find(str(self.passTotal))!= -1:
                    self.newPass()
                    writeFile(self.brain,self.brainFile)
                
                                 
    def trainLinker(self):
        try:
            f = open(trainFile,"r")
            block = f.read().lower()
        except:
            block = input("paste learning data:\n").lower()
        clean = ''.join(ch for ch in block if ch not in ignore)
        clean = clean.replace("\r"," ")
        clean = clean.replace("\n"," ")
        tasks = re.split('[!.?]\s',clean)
        #begin nested loop madness
        for task in tasks:
            if len(task)>0:
                if self.delvl > 1:
                    print("\n----Current Task: " + str(task)+"----")
                words = task.split(" ")
                if self.delvl > 1:
                    print("Words in Task: " + str(words)+"\n")
                for wor in words:
                    if len(wor)>0:
                        if self.delvl > 3:
                            print("--Current Word: " + str(wor)+"--")
                        flag = True
                        for item in self.brain:
                            if item.name == wor:
                                item.plusFollower(words[words.index(wor)+1:])
                                flag = False
                        if flag:
                            if words.index(wor) == 0:
                                self.brain.append(word(wor,0,words[words.index(wor)+1:],True))
                            else:
                                self.brain.append(word(wor,0,words[words.index(wor)+1:],False))
        if self.delvl > 3:
            print("\n\nTraining complete! Printing brain structure:\n\n")
            for item in self.brain:
                item.toString()
                print("")
        writeFile(self.brain,self.brainFile)
        print("Training Complete!")
        if self.delvl == -1:
            while 1:
                w = input("Probe brain for word:\n")
                for item in self.brain:
                    if item.name == w:
                        item.toString()
    def weightedChoice(self,word):
        choiceList = []
        if len(word.branches) < 1:
            flag = True
            for item in self.brain:
                if item.name == word.name:
                    flag = False
                    tempWord = item
                    if self.delvl > 3:
                        print("Breakout needed :(")
                    if len(tempWord.branches) < 1:
                        tempWord = self.findRando()
                        print("Jump needed >:(")
                    break
            if flag:
                tempWord = self.findRando()
                
        else:
            tempWord = word
            if self.delvl > 3:
                print("No BreakOut Needed!")
            
        for item in tempWord.branches:
            temp = item.counts
            while temp > 0:
                choiceList.append(item.name)
                temp-=1
        
        nextWord = choiceList[random.randint(0,len(choiceList)-1)]
        for item in tempWord.branches:
            if item.name == nextWord:
                return item
    def custom(self,word):
        original = word
        mess = "" + str(word.name) + " "
        while word.end == False or len(mess) < 20:      
            nextWord = self.weightedChoice(word)
            mess+=nextWord.name + " "
            word = nextWord
        if len(mess) > 200:
            return self.custom(original)
        else:
            return mess


    def findRando(self):
        temp = self.brain[random.randint(0,len(self.brain)-1)]
        while len(temp.branches) < 2:
            temp = self.brain[random.randint(0,len(self.brain)-1)]
        return temp


    def makeMessage(self):
        mess = ""
        word = self.brain[random.randint(0,len(self.brain)-1)]
        while word.start == False:
            word = self.brain[random.randint(0,len(self.brain)-1)]
        mess += str(word.name) + " "
        
        if self.delvl >2:
            print(str(mess))
            print(word.toString())
        while word.end == False or len(mess) < 20:      
            nextWord = self.weightedChoice(word)
            mess+=nextWord.name + " "
            word = nextWord
        if len(mess) > 200:
            return self.makeMessage()
        else:
            return mess 

    def livetrain(self,block):
        ignore = ['@','#',';','%','^','&','*','(',')','-','_','=',"\t",'`','<','>']
        block = block.lower()
        clean = ''.join(ch for ch in block if ch not in ignore)
        clean = clean.replace("\r"," ")
        clean = clean.replace("\n"," ")
        tasks = re.split('[!.?]\s',clean)
        #begin nested loop madness
        for task in tasks:
            if len(task)>0:
                if self.delvl > 1:
                    print("\n----Current Task: " + str(task)+"----")
                words = task.split(" ")
                if self.delvl > 1:
                    print("Words in Task: " + str(words)+"\n")
                for wor in words:
                    if len(wor)>0:
                        if str(wor).find("http") != -1 or str(wor).find("www") != -1 or wor.isdigit() == True:
                            continue
                        else:
                            if self.delvl > 3:
                                print("--Current Word: " + str(wor)+"--")
                            flag = True
                            for item in self.brain:
                                if item.name == wor:
                                    item.plusFollower(words[words.index(wor)+1:])
                                    flag = False
                            if flag:
                                if words.index(wor) == 0:
                                    self.brain.append(word(wor,0,words[words.index(wor)+1:],True))
                                else:
                                    self.brain.append(word(wor,0,words[words.index(wor)+1:],False))

Dank = SuperLinker()
